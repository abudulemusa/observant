<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Watchy by redbrain</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Watchy</h1>
        <h2>Simple Distributed Process and System Monitoring</h2>
        <a href="https://github.com/redbrain/watchy" class="button"><small>View project on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>
<a name="watchy" class="anchor" href="#watchy"><span class="octicon octicon-link"></span></a>Watchy</h1>

<p>Watchy is a distributed system for Application and Server Monitoring, I've always found most solutions be very complicated and hard to manage. Making applications watch process id's then they stop and the pid has updated and you start the whole thing over again.</p>

<p>Watchy has a distributed architecture and communication between the daemon on each server to the dashboard is over udp, meaning if something goes down and comes back up again it just simply doesn't matter about handling connection issues. It seems to be working very well in my tests at work and i am sure you will love it.</p>

<p><img src="http://redbrain.github.io/watchy/images/usage/watchy1.png" alt="alt text" title="Main dashboard showing all processes sending stats"></p>

<h2>
<a name="how-it-works" class="anchor" href="#how-it-works"><span class="octicon octicon-link"></span></a>How it works</h2>

<p>Watchy has a very application/event driven model and it can be seen in this diagram:
<img src="http://redbrain.github.io/watchy/images/arch/watchy1.png" alt="alt text" title="Arch1"></p>

<p>Each application can:</p>

<p>And you can even call these tools to talk to the server:</p>

<p>But whats interesting is you can then Federate all Watchy Servers onto a common backend such as Ganglia or MongoDB.:</p>

<p><img src="http://redbrain.github.io/watchy/images/arch/watchy2.png" alt="alt text" title="Federation onto a common backend"></p>

<p>This is great because you can then reuse your existing infrastructure. Watchy comes with a realtime web dashboard and you can view realtime graphs:</p>

<p><img src="http://redbrain.github.io/watchy/images/usage/watchy2.png" alt="alt text" title="Memory Usage"></p>

<p>You can even watch log files in realtime:</p>

<p><img src="http://redbrain.github.io/watchy/images/usage/watchy3.png" alt="alt text" title="Log"></p>

<p>This can be done via:</p>

<p>Or you can directly construct log packets:</p>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/redbrain/watchy/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/redbrain/watchy/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/redbrain/watchy"></a> is maintained by <a href="https://github.com/redbrain">redbrain</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>