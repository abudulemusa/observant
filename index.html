<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Watchy by redbrain</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Watchy</h1>
        <h2>Simple Distributed Process and System Monitoring</h2>
        <a href="https://github.com/redbrain/watchy" class="button"><small>View project on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>
<a name="watchy" class="anchor" href="#watchy"><span class="octicon octicon-link"></span></a>Watchy</h1>

<p>Using the UDP protocol opened up a new way of doing stats aggregation for me. Traditional methods of stats aggregation are daemons watching daemons creating more confusion on how to manage this as well as getting useful information.</p>

<p>Watchy has several components to it a Web Dashboard using Python Flask, and lots of $.ajax javascript on the client to see the data in realtime. A native C server on the host which reads from a unix domain socket and sends the stats to the server over udp. This way if the server goes down and comes back up everything keeps on running. Stats aggregation should be simple and easy and using TCP you have to worry about reconnecting sockets every time something goes off and on. And for Benchmarking and even capacity mangement you just want it to work not update what pids to watch and what server and port to manage.</p>

<p>Watchy's native C library is an embedable into applications where you talk to the runtime to tell it to watch a pid or sends even custom metrics from your application.</p>

<h2>
<a name="usage" class="anchor" href="#usage"><span class="octicon octicon-link"></span></a>Usage</h2>

<div class="highlight highlight-c"><pre><span class="n">watchy_cAttachRuntime</span> <span class="p">(</span><span class="n">socket_path</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span> <span class="c1">// if the server isn't running the daemon is started</span>
<span class="kt">void</span> <span class="n">watchy_watchPid</span> <span class="p">(</span><span class="n">getpid</span> <span class="p">())</span> <span class="c1">// tell the daemon to watch this pid and send stats to server</span>
</pre></div>

<p>Whats interesting with this approach applications can dynamically send stats so no need to manually update scripts with new pids this is all event driven in that if the application is running or not it will send stats or not.</p>

<p>And with the Dashboard going on and off it will all keep running no need to stop and restart services.</p>

<p><img src="http://redbrain.github.io/watchy/images/watchy1.png" alt="alt text" title="Main dashboard showing all processes sending stats"><img src="http://redbrain.github.io/watchy/images/watchy2.png" alt="alt text" title="Host showing total memory usage"><img src="http://redbrain.github.io/watchy/images/watchy3.png" alt="alt text" title="Watch a log file in realtime"></p>

<p>Although adding in code to do this is great watchy does come with tools to make things simple, you can do:
Sending stats can be done via:</p>

<div class="highlight highlight-bash"><pre><span class="nv">$ </span>/opt/watchy/bin/watcher -k <span class="sb">`</span>hostname<span class="sb">`</span> -b localhost -p 7878 process1:&lt;pid&gt; process2:&lt;pid&gt;
</pre></div>

<p>Or you can tail a log:</p>

<div class="highlight highlight-bash"><pre><span class="nv">$ </span>tail -f /var/log/syslog <span class="p">|</span> /opt/watchy/bin/wtail -k syslog -p 7878 -b localhost
</pre></div>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/redbrain/watchy/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/redbrain/watchy/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/redbrain/watchy"></a> is maintained by <a href="https://github.com/redbrain">redbrain</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>