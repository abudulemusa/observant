{"name":"Watchy","tagline":"Simple Distributed Process and System Monitoring","body":"# Watchy\r\n\r\nWatchy is a distributed system for Application and Server Monitoring, I've always found most solutions be very complicated and hard to manage. Making applications watch process id's then they stop and the pid has updated and you start the whole thing over again.\r\n\r\nWatchy has a distributed architecture and communication between the daemon on each server to the dashboard is over udp, meaning if something goes down and comes back up again it just simply doesn't matter about handling connection issues. It seems to be working very well in my tests at work and i am sure you will love it.\r\n\r\n![alt text](http://redbrain.github.io/watchy/images/usage/watchy1.png \"Main dashboard showing all processes sending stats\")\r\n\r\n## How it works\r\n\r\nWatchy has a very application/event driven model and it can be seen in this diagram:\r\n![alt text](http://redbrain.github.io/watchy/images/arch/watchy1.png \"Arch1\")\r\n\r\nEach application can:\r\n\r\nAnd you can even call these tools to talk to the server:\r\n\r\nBut whats interesting is you can then Federate all Watchy Servers onto a common backend such as Ganglia or MongoDB.:\r\n\r\n![alt text](http://redbrain.github.io/watchy/images/arch/watchy2.png \"Federation onto a common backend\")\r\n\r\nThis is great because you can then reuse your existing infrastructure. Watchy comes with a realtime web dashboard and you can view realtime graphs:\r\n\r\n![alt text](http://redbrain.github.io/watchy/images/usage/watchy2.png \"Memory Usage\")\r\n\r\nYou can even watch log files in realtime:\r\n\r\n![alt text](http://redbrain.github.io/watchy/images/usage/watchy3.png \"Log\")\r\n\r\nThis can be done via:\r\n\r\nOr you can directly construct log packets:\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}