{"name":"Watchy","tagline":"Simple Distributed Process and System Monitoring","body":"# Watchy\r\n\r\nUsing the UDP protocol opened up a new way of doing stats aggregation for me. Traditional methods of stats aggregation are daemons watching daemons creating more confusion on how to manage this as well as getting useful information.\r\n\r\nWatchy has several components to it a Web Dashboard using Python Flask, and lots of $.ajax javascript on the client to see the data in realtime. A native C server on the host which reads from a unix domain socket and sends the stats to the server over udp. This way if the server goes down and comes back up everything keeps on running. Stats aggregation should be simple and easy and using TCP you have to worry about reconnecting sockets every time something goes off and on. And for Benchmarking and even capacity mangement you just want it to work not update what pids to watch and what server and port to manage.\r\n\r\nWatchy's native C library is an embedable into applications where you talk to the runtime to tell it to watch a pid or sends even custom metrics from your application.\r\n\r\n## Usage\r\n\r\n```c\r\nwatchy_cAttachRuntime (socket_path, hostname, port) // if the server isn't running the daemon is started\r\nvoid watchy_watchPid (getpid ()) // tell the daemon to watch this pid and send stats to server\r\n```\r\n\r\nWhats interesting with this approach applications can dynamically send stats so no need to manually update scripts with new pids this is all event driven in that if the application is running or not it will send stats or not.\r\n\r\nAnd with the Dashboard going on and off it will all keep running no need to stop and restart services.\r\n\r\n![alt text](http://redbrain.github.io/watchy/images/watchy1.png \"Main dashboard showing all processes sending stats\")\r\n![alt text](http://redbrain.github.io/watchy/images/watchy2.png \"Host showing total memory usage\")\r\n![alt text](http://redbrain.github.io/watchy/images/watchy3.png \"Watch a log file in realtime\")\r\n\r\nAlthough adding in code to do this is great watchy does come with tools to make things simple, you can do:\r\nSending stats can be done via:\r\n\r\n```bash\r\n$ /opt/watchy/bin/watcher -k `hostname` -b localhost -p 7878 process1:<pid> process2:<pid>\r\n```\r\n\r\nOr you can tail a log:\r\n\r\n```bash\r\n$ tail -f /var/log/syslog | /opt/watchy/bin/wtail -k syslog -p 7878 -b localhost\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}